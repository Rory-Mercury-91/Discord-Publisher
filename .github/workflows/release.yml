name: Release Build

on:
  push:
    tags:
      - 'v*.*.*'

env:
  TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_PRIVATE_KEY_FRESH }}
  TAURI_SIGNING_PRIVATE_KEY_PASSWORD: ${{ secrets.TAURI_PASSWORD_FRESH }}

jobs:
  build-release:
    name: Build and Release
    runs-on: windows-latest
    permissions:
      contents: write
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          toolchain: stable

      - name: Rust cache
        uses: swatinem/rust-cache@v2
        with:
          workspaces: './src-tauri -> target'

      - name: Install dependencies
        run: |
          npm ci
          cd frontend && npm ci

      - name: Create .env file with all Vite environment variables
        shell: pwsh
        run: |
          $envContent = @"
          VITE_SUPABASE_URL=${{ secrets.VITE_SUPABASE_URL }}
          VITE_SUPABASE_ANON_KEY=${{ secrets.VITE_SUPABASE_ANON_KEY }}
          VITE_PUBLISHER_API_URL=${{ secrets.VITE_PUBLISHER_API_URL }}
          VITE_MASTER_ADMIN_CODE=${{ secrets.VITE_MASTER_ADMIN_CODE }}
          VITE_TAGS_MASTER_CODE=${{ secrets.VITE_TAGS_MASTER_CODE }}
          "@
          $envContent | Out-File -FilePath ".env" -Encoding utf8
          Write-Host "‚úÖ .env file created at root with all Vite variables"

      - name: Extract version from tag
        id: version
        shell: pwsh
        run: |
          $tag = "${{ github.ref_name }}"
          $version = $tag -replace '^v', ''
          echo "VERSION=$version" >> $env:GITHUB_OUTPUT
          Write-Host "‚úÖ Version extracted: $version"

      - name: Set version from tag
        shell: pwsh
        run: |
          $version = "${{ steps.version.outputs.VERSION }}"
          Write-Host "üîß Setting version to $version in all config files..."
          
          # package.json
          $pkg = Get-Content package.json | ConvertFrom-Json
          $pkg.version = $version
          $pkg | ConvertTo-Json -Depth 100 | Set-Content package.json -Encoding utf8
          
          # tauri.conf.json
          $tauri = Get-Content src-tauri/tauri.conf.json | ConvertFrom-Json
          $tauri.version = $version
          $tauri | ConvertTo-Json -Depth 100 | Set-Content src-tauri/tauri.conf.json -Encoding utf8
          
          # Cargo.toml - SEULEMENT la version dans [package], PAS rust-version
          $cargoContent = Get-Content src-tauri/Cargo.toml -Raw
          
          # Trouver la section [package]
          if ($cargoContent -match '\[package\]([\s\S]*?)(?=\n\[|$)') {
            $packageSection = $matches[1]
            
            # Remplacer UNIQUEMENT "version = " (pas rust-version)
            $updatedSection = $packageSection -replace '(?m)^version\s*=\s*"[^"]+"', "version = `"$version`""
            
            # Reconstruire le fichier
            $cargoContent = $cargoContent -replace [regex]::Escape($packageSection), $updatedSection
            
            $cargoContent | Set-Content src-tauri/Cargo.toml -NoNewline -Encoding utf8
            Write-Host "‚úÖ Cargo.toml updated"
          } else {
            Write-Host "‚ùå Could not find [package] section in Cargo.toml"
            exit 1
          }
          
          Write-Host "‚úÖ Version set to $version in all files"

      - name: Clean Cargo cache to avoid feature conflicts
        shell: pwsh
        run: |
          Write-Host "üßπ Cleaning Cargo build artifacts..."
          if (Test-Path "src-tauri/Cargo.lock") {
            Remove-Item "src-tauri/Cargo.lock" -Force
            Write-Host "‚úÖ Cargo.lock removed"
          }
          cd src-tauri
          cargo clean
          Write-Host "‚úÖ Cargo cache cleaned"

      - name: Force refresh environment secrets
        shell: pwsh
        run: |
          Write-Host "üîÑ Using FINAL secret names - no more cache!"
          Write-Host "Build timestamp: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss')"

      - name: Verify signing keys are set
        env:
          TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_PRIVATE_KEY_FRESH }}
          TAURI_SIGNING_PRIVATE_KEY_PASSWORD: ${{ secrets.TAURI_PASSWORD_FRESH }}
        shell: pwsh
        run: |
          Write-Host "üîê V√âRIFICATION COMPL√àTE DES SECRETS" -ForegroundColor Cyan
          Write-Host "=" * 80
          
          if ($env:TAURI_SIGNING_PRIVATE_KEY) {
            Write-Host "`n‚úÖ TAURI_SIGNING_PRIVATE_KEY trouv√©e" -ForegroundColor Green
            Write-Host "Longueur: $($env:TAURI_SIGNING_PRIVATE_KEY.Length) caract√®res"
            Write-Host "`nüìã CL√â COMPL√àTE:" -ForegroundColor Yellow
            Write-Host $env:TAURI_SIGNING_PRIVATE_KEY
            
            Write-Host "`nüéØ CL√â ATTENDUE:" -ForegroundColor Magenta
            Write-Host "dW50cnVzdGVkIGNvbW1lbnQ6IHJzaWduIGVuY3J5cHRlZCBzZWNyZXQga2V5ClJXUlRZMEl5WHpuUHZwNmJoWDRHakxuS0ZqUXZ3U21DS3MrMk9neHJGaG9BT0RqVGdIOEFBQkFBQUFBQUFBQUFBQUlBQUFBQUtBMzd2SDM5UUJ1anJ4U0tkTXJCSnJLV09icENtWVNla2owN0VCVW9DamUrYmVVaTFuaHR0MFFtZDd5Wjc1SmU1bTJROFp3NVhWNitvOCt5TC84MnMzZm9YaXBlVktCaE9sTVZIOWUyOXRRaWJLeUMvT1gvQkZiT256MCtvN2VrNEw5aUppWWNMa2s9Cg=="
            
            if ($env:TAURI_SIGNING_PRIVATE_KEY -eq "dW50cnVzdGVkIGNvbW1lbnQ6IHJzaWduIGVuY3J5cHRlZCBzZWNyZXQga2V5ClJXUlRZMEl5WHpuUHZwNmJoWDRHakxuS0ZqUXZ3U21DS3MrMk9neHJGaG9BT0RqVGdIOEFBQkFBQUFBQUFBQUFBQUlBQUFBQUtBMzd2SDM5UUJ1anJ4U0tkTXJCSnJLV09icENtWVNla2owN0VCVW9DamUrYmVVaTFuaHR0MFFtZDd5Wjc1SmU1bTJROFp3NVhWNitvOCt5TC84MnMzZm9YaXBlVktCaE9sTVZIOWUyOXRRaWJLeUMvT1gvQkZiT256MCtvN2VrNEw5aUppWWNMa2s9Cg==") {
              Write-Host "`n‚úÖ‚úÖ‚úÖ PARFAIT! La cl√© correspond exactement!" -ForegroundColor Green
            } else {
              Write-Host "`n‚ùå‚ùå‚ùå ERREUR! La cl√© est diff√©rente!" -ForegroundColor Red
              exit 1
            }
          } else {
            Write-Host "‚ùå TAURI_SIGNING_PRIVATE_KEY is NOT set" -ForegroundColor Red
            exit 1
          }
          
          Write-Host "`n" + ("=" * 80)
          
          if ($env:TAURI_SIGNING_PRIVATE_KEY_PASSWORD -ne $null) {
            Write-Host "`n‚úÖ TAURI_SIGNING_PRIVATE_KEY_PASSWORD trouv√©" -ForegroundColor Green
            Write-Host "üìã MOT DE PASSE COMPLET:" -ForegroundColor Yellow
            Write-Host $env:TAURI_SIGNING_PRIVATE_KEY_PASSWORD
            
            Write-Host "`nüéØ MOT DE PASSE ATTENDU:" -ForegroundColor Magenta
            Write-Host "2026"
            
            if ($env:TAURI_SIGNING_PRIVATE_KEY_PASSWORD -eq "2026") {
              Write-Host "`n‚úÖ‚úÖ‚úÖ PARFAIT! Le mot de passe correspond!" -ForegroundColor Green
            } else {
              Write-Host "`n‚ùå‚ùå‚ùå ERREUR! Le mot de passe est diff√©rent!" -ForegroundColor Red
              exit 1
            }
          } else {
            Write-Host "‚ö†Ô∏è TAURI_SIGNING_PRIVATE_KEY_PASSWORD is not set" -ForegroundColor Red
            exit 1
          }
          
          Write-Host "`n" + ("=" * 80)
          Write-Host "üéâ TOUS LES SECRETS SONT CORRECTS!" -ForegroundColor Green

      - name: Build application
        env:
          TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_PRIVATE_KEY_FRESH }}
          TAURI_SIGNING_PRIVATE_KEY_PASSWORD: ${{ secrets.TAURI_PASSWORD_FRESH }}
        run: npm run build

      - name: List build artifacts
        shell: pwsh
        run: |
          Write-Host "üì¶ Listing build artifacts..."
          if (Test-Path "src-tauri/target/release/bundle/nsis") {
            Write-Host "`nüìÇ NSIS Bundle contents:"
            Get-ChildItem -Recurse src-tauri/target/release/bundle/nsis | ForEach-Object {
              Write-Host "  $($_.FullName) - $($_.Length) bytes"
            }
          } else {
            Write-Host "‚ö†Ô∏è NSIS bundle directory not found"
          }
          if (Test-Path "src-tauri/target/release") {
            Write-Host "`nüìÇ Release exe files:"
            Get-ChildItem src-tauri/target/release/*.exe | ForEach-Object {
              Write-Host "  $($_.FullName) - $($_.Length) bytes"
            }
          }

      - name: Create portable version
        shell: pwsh
        run: |
          $version = "${{ steps.version.outputs.VERSION }}"
          $exePath = "src-tauri/target/release/app.exe"
          $portableName = "Discord_Publisher_${version}_portable.exe"
          
          Write-Host "üîç Looking for exe at: $exePath"
          
          if (Test-Path $exePath) {
            Copy-Item $exePath $portableName
            Write-Host "‚úÖ Portable version created: $portableName"
            
            # Verify the file was created
            if (Test-Path $portableName) {
              $fileSize = (Get-Item $portableName).Length / 1MB
              Write-Host "‚úÖ File size: $($fileSize.ToString('F2')) MB"
            }
          } else {
            Write-Host "‚ùå exe not found at $exePath"
            Write-Host "üìÇ Available exe files:"
            Get-ChildItem -Recurse src-tauri/target/release/*.exe
            exit 1
          }

      - name: Generate latest.json for update detection
        shell: pwsh
        run: |
          $version = "${{ steps.version.outputs.VERSION }}"
          $repoUrl = "https://github.com/${{ github.repository }}"
          $pubDate = (Get-Date).ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffZ")
          
          Write-Host "üîß Generating latest.json for version $version"
          
          # Trouver le fichier setup NSIS
          $setupFiles = Get-ChildItem -Path "src-tauri/target/release/bundle/nsis" -Filter "*-setup.exe"
          
          if ($setupFiles.Count -eq 0) {
            Write-Host "‚ùå No NSIS setup file found"
            exit 1
          }
          
          $setupFile = $setupFiles[0]
          $setupFileName = $setupFile.Name
          
          Write-Host "‚úÖ Found setup file: $setupFileName"
          Write-Host "üìä File size: $($setupFile.Length / 1MB) MB"
          
          # Cr√©er le JSON pour la d√©tection de version (simplifi√©)
          $latestJson = @{
            version = $version
            notes = "Nouvelle version de Discord Publisher"
            pub_date = $pubDate
            platforms = @{
              "windows-x86_64" = @{
                url = "$repoUrl/releases/download/${{ github.ref_name }}/$setupFileName"
              }
            }
          } | ConvertTo-Json -Depth 10
          
          $latestJson | Out-File -FilePath "latest.json" -Encoding utf8
          Write-Host "‚úÖ latest.json created:"
          Get-Content "latest.json"

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v1
        with:
          files: |
            src-tauri/target/release/bundle/nsis/*.exe
            latest.json
            Discord_Publisher_${{ steps.version.outputs.VERSION }}_portable.exe
          name: Discord Publisher v${{ steps.version.outputs.VERSION }}
          body: |
            ## üéâ Nouvelle version : ${{ steps.version.outputs.VERSION }}
            
            ### üì¶ Fichiers disponibles
            
            - **Installateur NSIS** : Installation compl√®te avec mise √† jour automatique
            - **Version portable** : Ex√©cutable standalone sans installation
            
            ### üîß Installation
            
            #### Installateur (recommand√©)
            1. T√©l√©charger le fichier `Discord Publisher_*_x64-setup.exe`
            2. Ex√©cuter le fichier et suivre les instructions
            3. Lancer l'application depuis le menu D√©marrer
            
            #### Version portable
            1. T√©l√©charger `Discord_Publisher_${{ steps.version.outputs.VERSION }}_portable.exe`
            2. Placer le fichier o√π vous voulez
            3. Double-cliquer pour lancer (aucune installation requise)
            
            ### üîÑ Mise √† jour automatique
            
            Si vous avez d√©j√† Discord Publisher install√© :
            - L'application d√©tectera automatiquement cette nouvelle version
            - Une notification vous proposera de t√©l√©charger la mise √† jour
            - Cliquez sur "T√©l√©charger" puis "Installer maintenant" pour mettre √† jour
            
            ### üìù Changelog
            
            *Voir les commits ci-dessous pour les d√©tails des changements.*
            
            ---
            
            **Build date** : ${{ github.event.head_commit.timestamp }}  
            **Commit** : `${{ github.sha }}`
          draft: false
          prerelease: false
          generate_release_notes: true
          fail_on_unmatched_files: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Send Discord Notification
        if: success()
        env:
          DISCORD_WEBHOOK_URL: ${{ secrets.DISCORD_WEBHOOK_URL }}
        shell: pwsh
        run: |
          if (-not $env:DISCORD_WEBHOOK_URL) {
            Write-Host "Discord webhook not configured, skipping notification"
            exit 0
          }
          
          $version = "${{ steps.version.outputs.VERSION }}"
          $releaseUrl = "https://github.com/${{ github.repository }}/releases/tag/${{ github.ref_name }}"
          
          $payload = @{
            embeds = @(@{
              title = "üöÄ Nouvelle version disponible !"
              description = "Discord Publisher v$version vient d'√™tre publi√©"
              color = 5814783
              fields = @(
                @{
                  name = "Version"
                  value = "``$version``"
                  inline = $true
                },
                @{
                  name = "Plateforme"
                  value = "Windows (Version portable + Installateur NSIS)"
                  inline = $true
                },
                @{
                  name = "Build"
                  value = "Succ√®s ‚úÖ"
                  inline = $true
                }
              )
              url = $releaseUrl
              timestamp = (Get-Date).ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffZ")
              footer = @{
                text = "GitHub Actions"
              }
            })
          } | ConvertTo-Json -Depth 10
          
          try {
            Invoke-RestMethod -Uri $env:DISCORD_WEBHOOK_URL -Method Post -Body $payload -ContentType "application/json"
            Write-Host "‚úÖ Discord notification sent successfully"
          } catch {
            Write-Host "‚ö†Ô∏è Failed to send Discord notification: $_"
            exit 0
          }

      - name: Notify build failure to Discord
        if: failure()
        env:
          DISCORD_WEBHOOK_URL: ${{ secrets.DISCORD_WEBHOOK_URL }}
        shell: pwsh
        run: |
          if (-not $env:DISCORD_WEBHOOK_URL) {
            exit 0
          }
          
          $version = "${{ steps.version.outputs.VERSION }}"
          $workflowUrl = "https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}"
          
          $payload = @{
            embeds = @(@{
              title = "‚ùå Build √©chou√©"
              description = "Le build de Discord Publisher v$version a √©chou√©"
              color = 15158332
              fields = @(
                @{
                  name = "Version"
                  value = "``$version``"
                  inline = $true
                },
                @{
                  name = "Build"
                  value = "√âchec ‚ùå"
                  inline = $true
                }
              )
              url = $workflowUrl
              timestamp = (Get-Date).ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffZ")
              footer = @{
                text = "GitHub Actions"
              }
            })
          } | ConvertTo-Json -Depth 10
          
          try {
            Invoke-RestMethod -Uri $env:DISCORD_WEBHOOK_URL -Method Post -Body $payload -ContentType "application/json"
          } catch {
            exit 0
          }
