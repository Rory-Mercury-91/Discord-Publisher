name: Release Build

on:
  push:
    tags:
      - 'v*.*.*'

env:
  TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_PRIVATE_KEY_FRESH }}
  TAURI_SIGNING_PRIVATE_KEY_PASSWORD: ${{ secrets.TAURI_PASSWORD_FRESH }}

jobs:
  build-release:
    name: Build and Release
    runs-on: windows-latest
    permissions:
      contents: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          toolchain: stable

      - name: Rust cache
        uses: swatinem/rust-cache@v2
        with:
          workspaces: './src-tauri -> target'

      - name: Install dependencies
        run: |
          npm ci
          cd frontend && npm ci

      - name: Create .env file with all Vite environment variables
        shell: pwsh
        run: |
          $envContent = @"
          VITE_SUPABASE_URL=${{ secrets.VITE_SUPABASE_URL }}
          VITE_SUPABASE_ANON_KEY=${{ secrets.VITE_SUPABASE_ANON_KEY }}
          VITE_PUBLISHER_API_URL=${{ secrets.VITE_PUBLISHER_API_URL }}
          VITE_MASTER_ADMIN_CODE=${{ secrets.VITE_MASTER_ADMIN_CODE }}
          VITE_TAGS_MASTER_CODE=${{ secrets.VITE_TAGS_MASTER_CODE }}
          "@
          $envContent | Out-File -FilePath ".env" -Encoding utf8
          Write-Host "‚úÖ .env file created at root with all Vite variables"

      - name: Extract version from tag
        id: version
        shell: pwsh
        run: |
          $tag = "${{ github.ref_name }}"
          $version = $tag -replace '^v', ''
          echo "VERSION=$version" >> $env:GITHUB_OUTPUT
          Write-Host "‚úÖ Version extracted: $version"

      - name: Set version from tag
        shell: pwsh
        run: |
          $version = "${{ steps.version.outputs.VERSION }}"
          Write-Host "üîß Setting version to $version in all config files."

          # package.json
          $pkg = Get-Content package.json | ConvertFrom-Json
          $pkg.version = $version
          $pkg | ConvertTo-Json -Depth 100 | Set-Content package.json -Encoding utf8

          # tauri.conf.json
          $tauri = Get-Content src-tauri/tauri.conf.json | ConvertFrom-Json
          $tauri.version = $version
          $tauri | ConvertTo-Json -Depth 100 | Set-Content src-tauri/tauri.conf.json -Encoding utf8

          # Cargo.toml - ONLY [package] version (not rust-version)
          $cargoContent = Get-Content src-tauri/Cargo.toml -Raw

          if ($cargoContent -match '\[package\]([\s\S]*?)(?=\n\[|$)') {
            $packageSection = $matches[1]
            $updatedSection = $packageSection -replace '(?m)^version\s*=\s*"[^"]+"', "version = `"$version`""
            $cargoContent = $cargoContent -replace [regex]::Escape($packageSection), $updatedSection
            $cargoContent | Set-Content src-tauri/Cargo.toml -NoNewline -Encoding utf8
            Write-Host "‚úÖ Cargo.toml updated"
          } else {
            Write-Host "‚ùå Could not find [package] section in Cargo.toml"
            exit 1
          }

          Write-Host "‚úÖ Version set to $version in all files"

      - name: Clean Cargo cache to avoid feature conflicts
        shell: pwsh
        run: |
          Write-Host "üßπ Cleaning Cargo build artifacts."
          if (Test-Path "src-tauri/Cargo.lock") {
            Remove-Item "src-tauri/Cargo.lock" -Force
            Write-Host "‚úÖ Cargo.lock removed"
          }
          cd src-tauri
          cargo clean
          Write-Host "‚úÖ Cargo cache cleaned"

      - name: Force refresh environment secrets
        shell: pwsh
        run: |
          Write-Host "üîÑ Using FINAL secret names - no more cache!"
          Write-Host "Build timestamp: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss')"

      - name: Verify signing keys are set (safe)
        env:
          TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_PRIVATE_KEY_FRESH }}
          TAURI_SIGNING_PRIVATE_KEY_PASSWORD: ${{ secrets.TAURI_PASSWORD_FRESH }}
        shell: pwsh
        run: |
          Write-Host "üîê Checking signing env vars (without printing secrets)" -ForegroundColor Cyan
          if (-not $env:TAURI_SIGNING_PRIVATE_KEY) {
            Write-Host "‚ùå TAURI_SIGNING_PRIVATE_KEY is NOT set" -ForegroundColor Red
            exit 1
          }
          if (-not $env:TAURI_SIGNING_PRIVATE_KEY_PASSWORD) {
            Write-Host "‚ùå TAURI_SIGNING_PRIVATE_KEY_PASSWORD is NOT set" -ForegroundColor Red
            exit 1
          }
          Write-Host "‚úÖ Signing env vars are present"
          Write-Host "Key length: $($env:TAURI_SIGNING_PRIVATE_KEY.Length)"
          Write-Host "Password length: $($env:TAURI_SIGNING_PRIVATE_KEY_PASSWORD.Length)"

      - name: Build application
        env:
          TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_PRIVATE_KEY_FRESH }}
          TAURI_SIGNING_PRIVATE_KEY_PASSWORD: ${{ secrets.TAURI_PASSWORD_FRESH }}
        run: npm run build

      - name: Prepare Portable Binary
        shell: pwsh
        run: |
          Write-Host "üîß Pr√©paration du binaire portable..."
          $releaseDir = "src-tauri/target/release"

          # Cherche un exe principal (pas setup / pas sig)
          $exePath = Get-ChildItem -Path $releaseDir -Filter *.exe -File -ErrorAction SilentlyContinue |
            Where-Object { $_.Name -notlike "*setup*" -and $_.Name -notlike "*.sig" } |
            Sort-Object Length -Descending |
            Select-Object -First 1

          if ($exePath) {
            Copy-Item $exePath.FullName -Destination "$releaseDir/app.exe" -Force
            Write-Host "‚úÖ Binaire portable pr√™t : $releaseDir/app.exe"
          } else {
            Write-Error "‚ùå Impossible de trouver le binaire portable original."
            Write-Host "üìÇ Contenu de $releaseDir :"
            Get-ChildItem -Path $releaseDir -ErrorAction SilentlyContinue | Format-Table Name, Length
            exit 1
          }

      - name: Create app.exe only asset (zip)
        shell: pwsh
        run: |
          $version = "${{ steps.version.outputs.VERSION }}"
          $exePath = "src-tauri/target/release/app.exe"

          if (-not (Test-Path $exePath)) {
            Write-Error "‚ùå app.exe introuvable √† $exePath"
            exit 1
          }

          $outDir = "app-exe-only"
          if (Test-Path $outDir) { Remove-Item $outDir -Recurse -Force }
          New-Item -ItemType Directory -Force -Path $outDir | Out-Null

          Copy-Item $exePath -Destination (Join-Path $outDir "app.exe") -Force

          $zipName = "Discord_Publisher_${version}_app.exe_only.zip"
          if (Test-Path $zipName) { Remove-Item $zipName -Force }

          Compress-Archive -Path "$outDir/app.exe" -DestinationPath $zipName
          Write-Host "‚úÖ Asset cr√©√© : $zipName"

      - name: List build artifacts
        shell: pwsh
        run: |
          Write-Host "üì¶ Listing build artifacts."
          if (Test-Path "src-tauri/target/release/bundle/nsis") {
            Write-Host "`nüìÇ NSIS Bundle contents:"
            Get-ChildItem -Recurse src-tauri/target/release/bundle/nsis | ForEach-Object {
              Write-Host "  $($_.FullName) - $($_.Length) bytes"
            }
          } else {
            Write-Host "‚ö†Ô∏è NSIS bundle directory not found"
          }

          if (Test-Path "src-tauri/target/release") {
            Write-Host "`nüìÇ Release directory files:"
            Get-ChildItem src-tauri/target/release -File | ForEach-Object {
              Write-Host "  $($_.FullName) - $($_.Length) bytes"
            }
          }

      - name: Create portable version (single exe)
        shell: pwsh
        run: |
          $version = "${{ steps.version.outputs.VERSION }}"
          $exePath = "src-tauri/target/release/app.exe"
          $portableName = "Discord_Publisher_${version}_portable.exe"

          Write-Host "üîç Looking for exe at: $exePath"

          if (Test-Path $exePath) {
            Copy-Item $exePath $portableName -Force
            Write-Host "‚úÖ Portable version created: $portableName"

            if (Test-Path $portableName) {
              $fileSize = (Get-Item $portableName).Length / 1MB
              Write-Host "‚úÖ File size: $($fileSize.ToString('F2')) MB"
            }
          } else {
            Write-Host "‚ùå exe not found at $exePath"
            Write-Host "üìÇ Available exe files:"
            Get-ChildItem -Recurse src-tauri/target/release/*.exe
            exit 1
          }

      - name: Create portable full package (zip)
        shell: pwsh
        run: |
          $version = "${{ steps.version.outputs.VERSION }}"
          $releaseDir = "src-tauri/target/release"
          $portableDir = "portable_full"

          if (Test-Path $portableDir) { Remove-Item $portableDir -Recurse -Force }
          New-Item -ItemType Directory -Force -Path $portableDir | Out-Null

          # app.exe (nom fixe √† l'int√©rieur du zip)
          Copy-Item "$releaseDir/app.exe" -Destination "$portableDir/app.exe" -Force

          # D√©pendances typiques (tu peux ajuster si besoin)
          Get-ChildItem $releaseDir -File -ErrorAction SilentlyContinue |
            Where-Object {
              $_.Name -notlike "*setup*" -and
              $_.Name -notlike "*.sig" -and
              $_.Extension -in @(".dll",".dat",".bin",".json",".toml",".ini")
            } |
            ForEach-Object { Copy-Item $_.FullName -Destination $portableDir -Force }

          # Dossiers optionnels fr√©quents
          foreach ($dir in @("resources","locales")) {
            $src = Join-Path $releaseDir $dir
            if (Test-Path $src) {
              Copy-Item $src -Destination (Join-Path $portableDir $dir) -Recurse -Force
            }
          }

          $zipName = "Discord_Publisher_${version}_portable_full.zip"
          if (Test-Path $zipName) { Remove-Item $zipName -Force }

          Compress-Archive -Path "$portableDir/*" -DestinationPath $zipName
          Write-Host "‚úÖ Portable full zip created: $zipName"

      - name: Generate latest.json for update detection
        shell: pwsh
        run: |
          $version = "${{ steps.version.outputs.VERSION }}"
          $repoUrl = "https://github.com/${{ github.repository }}"
          $pubDate = (Get-Date).ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffZ")

          Write-Host "üîß Generating latest.json for version $version"

          # Trouver le fichier setup NSIS
          $setupFiles = Get-ChildItem -Path "src-tauri/target/release/bundle/nsis" -Filter "*-setup.exe"
          if ($setupFiles.Count -eq 0) {
            Write-Host "‚ùå No NSIS setup file found"
            exit 1
          }

          $setupFile = $setupFiles[0]
          $setupFileName = $setupFile.Name
          $sigFileName = "$setupFileName.sig"

          # V√©rifier signature
          $sigFile = Join-Path $setupFile.DirectoryName $sigFileName
          if (-not (Test-Path $sigFile)) {
            Write-Host "‚ùå Signature file not found: $sigFile"
            exit 1
          }

          $signatureContent = Get-Content -Path $sigFile -Raw
          Write-Host "‚úÖ Signature content loaded"

          # Assets additionnels (hybride)
          $portableFullZip = "Discord_Publisher_${version}_portable_full.zip"
          $appExeOnlyZip   = "Discord_Publisher_${version}_app.exe_only.zip"

          if (-not (Test-Path $portableFullZip)) { Write-Host "‚ùå Missing $portableFullZip"; exit 1 }
          if (-not (Test-Path $appExeOnlyZip))   { Write-Host "‚ùå Missing $appExeOnlyZip"; exit 1 }

          $portableFullSha = (Get-FileHash $portableFullZip -Algorithm SHA256).Hash.ToLower()
          $appExeOnlySha   = (Get-FileHash $appExeOnlyZip -Algorithm SHA256).Hash.ToLower()

          # JSON Tauri + champs custom (non cassants)
          $latestJson = @{
            version  = $version
            notes    = "Nouvelle version de Discord Publisher"
            pub_date = $pubDate

            platforms = @{
              "windows-x86_64" = @{
                url       = "$repoUrl/releases/download/${{ github.ref_name }}/$setupFileName"
                signature = $signatureContent
              }
            }

            assets = @{
              portable_full = @{
                url    = "$repoUrl/releases/download/${{ github.ref_name }}/$portableFullZip"
                sha256 = $portableFullSha
              }
              app_exe_only = @{
                url    = "$repoUrl/releases/download/${{ github.ref_name }}/$appExeOnlyZip"
                sha256 = $appExeOnlySha
              }
            }
          } | ConvertTo-Json -Depth 10

          $latestJson | Out-File -FilePath "latest.json" -Encoding utf8
          Write-Host "‚úÖ latest.json created"
          Get-Content "latest.json"

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v1
        with:
          files: |
            src-tauri/target/release/bundle/nsis/*.exe
            latest.json
            Discord_Publisher_${{ steps.version.outputs.VERSION }}_portable.exe
            Discord_Publisher_${{ steps.version.outputs.VERSION }}_portable_full.zip
            Discord_Publisher_${{ steps.version.outputs.VERSION }}_app.exe_only.zip
          name: Discord Publisher v${{ steps.version.outputs.VERSION }}
          body: |
            ## üéâ Nouvelle version : ${{ steps.version.outputs.VERSION }}

            ### üì¶ Fichiers disponibles

            - **Installateur NSIS** : installation compl√®te (setup)
            - **Version portable (1 fichier)** : `Discord_Publisher_${{ steps.version.outputs.VERSION }}_portable.exe`
            - **Version portable compl√®te (zip)** : `Discord_Publisher_${{ steps.version.outputs.VERSION }}_portable_full.zip`
            - **Mise √† jour hybride (app.exe uniquement)** : `Discord_Publisher_${{ steps.version.outputs.VERSION }}_app.exe_only.zip`
            - **Fichier de d√©tection** : `latest.json`
            - **Sources** : disponibles automatiquement via GitHub ("Source code")

            ### üîß Installation

            #### Installateur (recommand√©)
            1. T√©l√©charger le fichier `Discord Publisher_*_x64-setup.exe`
            2. Ex√©cuter le fichier et suivre les instructions
            3. Lancer l'application depuis le menu D√©marrer

            #### Version portable
            - **Simple** : t√©l√©charger `Discord_Publisher_${{ steps.version.outputs.VERSION }}_portable.exe` et lancer
            - **Compl√®te** : t√©l√©charger `Discord_Publisher_${{ steps.version.outputs.VERSION }}_portable_full.zip`, extraire, puis lancer `app.exe`

            ### üîÑ Mise √† jour (hybride)
            - Install√© : d√©tection via `latest.json` + mise √† jour via setup
            - Portable : ton syst√®me peut t√©l√©charger `*_app.exe_only.zip` et remplacer `app.exe`

            ---

            **Build date** : ${{ github.event.head_commit.timestamp }}
            **Commit** : `${{ github.sha }}`
          draft: false
          prerelease: false
          generate_release_notes: true
          fail_on_unmatched_files: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Send Discord Notification
        if: success()
        env:
          DISCORD_WEBHOOK_URL: ${{ secrets.DISCORD_WEBHOOK_URL }}
        shell: pwsh
        run: |
          if (-not $env:DISCORD_WEBHOOK_URL) {
            Write-Host "Discord webhook not configured, skipping notification"
            exit 0
          }

          $version = "${{ steps.version.outputs.VERSION }}"
          $releaseUrl = "https://github.com/${{ github.repository }}/releases/tag/${{ github.ref_name }}"

          $payload = @{
            embeds = @(@{
              title = "üöÄ Nouvelle version disponible !"
              description = "Discord Publisher v$version vient d'√™tre publi√©"
              color = 5814783
              fields = @(
                @{
                  name = "Version"
                  value = "``$version``"
                  inline = $true
                },
                @{
                  name = "Plateforme"
                  value = "Windows (Portable + NSIS + Hybride)"
                  inline = $true
                },
                @{
                  name = "Build"
                  value = "Succ√®s ‚úÖ"
                  inline = $true
                }
              )
              url = $releaseUrl
              timestamp = (Get-Date).ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffZ")
              footer = @{
                text = "GitHub Actions"
              }
            })
          } | ConvertTo-Json -Depth 10

          try {
            Invoke-RestMethod -Uri $env:DISCORD_WEBHOOK_URL -Method Post -Body $payload -ContentType "application/json"
            Write-Host "‚úÖ Discord notification sent successfully"
          } catch {
            Write-Host "‚ö†Ô∏è Failed to send Discord notification: $_"
            exit 0
          }

      - name: Notify build failure to Discord
        if: failure()
        env:
          DISCORD_WEBHOOK_URL: ${{ secrets.DISCORD_WEBHOOK_URL }}
        shell: pwsh
        run: |
          if (-not $env:DISCORD_WEBHOOK_URL) {
            exit 0
          }

          $version = "${{ steps.version.outputs.VERSION }}"
          $workflowUrl = "https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}"

          $payload = @{
            embeds = @(@{
              title = "‚ùå Build √©chou√©"
              description = "Le build de Discord Publisher v$version a √©chou√©"
              color = 15158332
              fields = @(
                @{
                  name = "Version"
                  value = "``$version``"
                  inline = $true
                },
                @{
                  name = "Build"
                  value = "√âchec ‚ùå"
                  inline = $true
                }
              )
              url = $workflowUrl
              timestamp = (Get-Date).ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffZ")
              footer = @{
                text = "GitHub Actions"
              }
            })
          } | ConvertTo-Json -Depth 10

          try {
            Invoke-RestMethod -Uri $env:DISCORD_WEBHOOK_URL -Method Post -Body $payload -ContentType "application/json"
          } catch {
            exit 0
          }
