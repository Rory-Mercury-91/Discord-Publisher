name: Release Build

on:
  push:
    tags:
      - 'v*.*.*'

env:
  TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}
  TAURI_KEY_PASSWORD: ${{ secrets.TAURI_KEY_PASSWORD }}

jobs:
  build-release:
    name: Build and Release
    runs-on: windows-latest
    permissions:
      contents: write
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          toolchain: stable

      - name: Rust cache
        uses: swatinem/rust-cache@v2
        with:
          workspaces: './src-tauri -> target'

      - name: Install dependencies
        run: |
          npm ci
          cd frontend && npm ci

      - name: Create .env file with all Vite environment variables
        shell: pwsh
        run: |
          $envContent = @"
          VITE_SUPABASE_URL=${{ secrets.VITE_SUPABASE_URL }}
          VITE_SUPABASE_ANON_KEY=${{ secrets.VITE_SUPABASE_ANON_KEY }}
          VITE_PUBLISHER_API_URL=${{ secrets.VITE_PUBLISHER_API_URL }}
          VITE_MASTER_ADMIN_CODE=${{ secrets.VITE_MASTER_ADMIN_CODE }}
          VITE_TAGS_MASTER_CODE=${{ secrets.VITE_TAGS_MASTER_CODE }}
          "@
          $envContent | Out-File -FilePath ".env" -Encoding utf8
          Write-Host "‚úÖ .env file created at root with all Vite variables"

      - name: Extract version from tag
        id: version
        shell: pwsh
        run: |
          $tag = "${{ github.ref_name }}"
          $version = $tag -replace '^v', ''
          echo "VERSION=$version" >> $env:GITHUB_OUTPUT
          Write-Host "‚úÖ Version extracted: $version"

      - name: Set version from tag
        shell: pwsh
        run: |
          $version = "${{ steps.version.outputs.VERSION }}"
          Write-Host "üîß Setting version to $version in all config files..."
          
          # package.json
          $pkg = Get-Content package.json | ConvertFrom-Json
          $pkg.version = $version
          $pkg | ConvertTo-Json -Depth 100 | Set-Content package.json -Encoding utf8
          
          # tauri.conf.json
          $tauri = Get-Content src-tauri/tauri.conf.json | ConvertFrom-Json
          $tauri.version = $version
          $tauri | ConvertTo-Json -Depth 100 | Set-Content src-tauri/tauri.conf.json -Encoding utf8
          
          # Cargo.toml - SEULEMENT la version dans [package], PAS rust-version
          $cargoContent = Get-Content src-tauri/Cargo.toml -Raw
          
          # Trouver la section [package]
          if ($cargoContent -match '\[package\]([\s\S]*?)(?=\n\[|$)') {
            $packageSection = $matches[1]
            
            # Remplacer UNIQUEMENT "version = " (pas rust-version)
            $updatedSection = $packageSection -replace '(?m)^version\s*=\s*"[^"]+"', "version = `"$version`""
            
            # Reconstruire le fichier
            $cargoContent = $cargoContent -replace [regex]::Escape($packageSection), $updatedSection
            
            $cargoContent | Set-Content src-tauri/Cargo.toml -NoNewline -Encoding utf8
            Write-Host "‚úÖ Cargo.toml updated"
          } else {
            Write-Host "‚ùå Could not find [package] section in Cargo.toml"
            exit 1
          }
          
          Write-Host "‚úÖ Version set to $version in all files"

      - name: Build application
        run: npm run build

      - name: List build artifacts
        shell: pwsh
        run: |
          Write-Host "üì¶ Listing build artifacts..."
          if (Test-Path "src-tauri/target/release/bundle/nsis") {
            Write-Host "`nüìÇ NSIS Bundle contents:"
            Get-ChildItem -Recurse src-tauri/target/release/bundle/nsis | ForEach-Object {
              Write-Host "  $($_.FullName) - $($_.Length) bytes"
            }
          } else {
            Write-Host "‚ö†Ô∏è NSIS bundle directory not found"
          }
          if (Test-Path "src-tauri/target/release") {
            Write-Host "`nüìÇ Release exe files:"
            Get-ChildItem src-tauri/target/release/*.exe | ForEach-Object {
              Write-Host "  $($_.FullName) - $($_.Length) bytes"
            }
          }
          if (Test-Path "src-tauri/target/release/bundle") {
            Write-Host "`nüìÇ All bundle files (.sig):"
            Get-ChildItem -Recurse src-tauri/target/release/bundle -Filter "*.sig" | ForEach-Object {
              Write-Host "  $($_.FullName)"
            }
          }

      - name: Create portable version
        shell: pwsh
        run: |
          $version = "${{ steps.version.outputs.VERSION }}"
          $exePath = "src-tauri/target/release/app.exe"
          $portableName = "Discord_Publisher_${version}_portable.exe"
          
          Write-Host "üîç Looking for exe at: $exePath"
          
          if (Test-Path $exePath) {
            Copy-Item $exePath $portableName
            Write-Host "‚úÖ Portable version created: $portableName"
            
            # Verify the file was created
            if (Test-Path $portableName) {
              $fileSize = (Get-Item $portableName).Length / 1MB
              Write-Host "‚úÖ File size: $($fileSize.ToString('F2')) MB"
            }
          } else {
            Write-Host "‚ùå exe not found at $exePath"
            Write-Host "üìÇ Available exe files:"
            Get-ChildItem -Recurse src-tauri/target/release/*.exe
            exit 1
          }

      - name: Generate latest.json for Tauri updater
        shell: pwsh
        run: |
          $version = "${{ steps.version.outputs.VERSION }}"
          $repoUrl = "https://github.com/${{ github.repository }}"
          $pubDate = (Get-Date).ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffZ")
          
          Write-Host "üìù Generating latest.json for version $version"
          
          # Trouver le fichier .exe NSIS
          $nsisExe = Get-ChildItem -Path "src-tauri/target/release/bundle/nsis" -Filter "*setup.exe" -Recurse | Select-Object -First 1
          
          if (-not $nsisExe) {
            Write-Host "‚ùå NSIS setup.exe file not found"
            Write-Host "üìÇ Listing NSIS directory:"
            Get-ChildItem -Path "src-tauri/target/release/bundle/nsis" -Recurse | ForEach-Object {
              Write-Host "  $($_.FullName)"
            }
            exit 1
          }
          
          Write-Host "‚úÖ Found exe: $($nsisExe.Name)"
          
          # Chercher le fichier .sig correspondant
          $sigPath = $nsisExe.FullName + ".sig"
          
          if (-not (Test-Path $sigPath)) {
            Write-Host "‚ùå Signature file not found at: $sigPath"
            Write-Host "üìÇ Looking for .sig files:"
            Get-ChildItem -Path "src-tauri/target/release/bundle" -Filter "*.sig" -Recurse | ForEach-Object {
              Write-Host "  Found: $($_.FullName)"
            }
            exit 1
          }
          
          Write-Host "‚úÖ Found signature: $sigPath"
          
          # Cr√©er le .nsis.zip √† partir du .exe
          $zipFileName = "Discord_Publisher_${version}_x64_setup.nsis.zip"
          Compress-Archive -Path $nsisExe.FullName -DestinationPath $zipFileName -Force
          Write-Host "‚úÖ Created: $zipFileName"
          
          # Lire la signature
          $signature = Get-Content $sigPath -Raw -Encoding UTF8
          Write-Host "‚úÖ Signature length: $($signature.Length) chars"
          
          # Cr√©er le JSON pour Tauri updater
          $latestJson = @{
            version = $version
            notes = "Nouvelle version de Discord Publisher"
            pub_date = $pubDate
            platforms = @{
              "windows-x86_64" = @{
                signature = $signature.Trim()
                url = "$repoUrl/releases/download/${{ github.ref_name }}/$zipFileName"
              }
            }
          } | ConvertTo-Json -Depth 10
          
          $latestJson | Out-File -FilePath "latest.json" -Encoding utf8
          Write-Host "‚úÖ latest.json created:"
          Get-Content "latest.json"

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v1
        with:
          files: |
            src-tauri/target/release/bundle/nsis/*.exe
            Discord_Publisher_${{ steps.version.outputs.VERSION }}_x64_setup.nsis.zip
            latest.json
            Discord_Publisher_${{ steps.version.outputs.VERSION }}_portable.exe
          name: Discord Publisher v${{ steps.version.outputs.VERSION }}
          body: |
            ## üéâ Nouvelle version : ${{ steps.version.outputs.VERSION }}
            
            ### üì¶ Fichiers disponibles
            
            - **Installateur NSIS** : Installation compl√®te avec mise √† jour automatique
            - **Version portable** : Ex√©cutable standalone sans installation
            
            ### üîß Installation
            
            #### Installateur (recommand√©)
            1. T√©l√©charger le fichier `Discord Publisher_*_x64-setup.exe`
            2. Ex√©cuter le fichier et suivre les instructions
            3. Lancer l'application depuis le menu D√©marrer
            
            #### Version portable
            1. T√©l√©charger `Discord_Publisher_${{ steps.version.outputs.VERSION }}_portable.exe`
            2. Placer le fichier o√π vous voulez
            3. Double-cliquer pour lancer (aucune installation requise)
            
            ### üîÑ Mise √† jour automatique
            
            Si vous avez d√©j√† Discord Publisher install√© :
            - L'application d√©tectera automatiquement cette nouvelle version
            - Une notification vous proposera de mettre √† jour
            - Cliquez sur "Installer" pour t√©l√©charger et installer
            
            ### üìù Changelog
            
            *Voir les commits ci-dessous pour les d√©tails des changements.*
            
            ---
            
            **Build date** : ${{ github.event.head_commit.timestamp }}  
            **Commit** : `${{ github.sha }}`
          draft: false
          prerelease: false
          generate_release_notes: true
          fail_on_unmatched_files: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Send Discord Notification
        if: success()
        env:
          DISCORD_WEBHOOK_URL: ${{ secrets.DISCORD_WEBHOOK_URL }}
        shell: pwsh
        run: |
          if (-not $env:DISCORD_WEBHOOK_URL) {
            Write-Host "Discord webhook not configured, skipping notification"
            exit 0
          }
          
          $version = "${{ steps.version.outputs.VERSION }}"
          $releaseUrl = "https://github.com/${{ github.repository }}/releases/tag/${{ github.ref_name }}"
          
          $payload = @{
            embeds = @(@{
              title = "üöÄ Nouvelle version disponible !"
              description = "Discord Publisher v$version vient d'√™tre publi√©"
              color = 5814783
              fields = @(
                @{
                  name = "Version"
                  value = "``$version``"
                  inline = $true
                },
                @{
                  name = "Plateforme"
                  value = "Windows (NSIS + Portable)"
                  inline = $true
                },
                @{
                  name = "Build"
                  value = "Succ√®s ‚úÖ"
                  inline = $true
                }
              )
              url = $releaseUrl
              timestamp = (Get-Date).ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffZ")
              footer = @{
                text = "GitHub Actions"
              }
            })
          } | ConvertTo-Json -Depth 10
          
          try {
            Invoke-RestMethod -Uri $env:DISCORD_WEBHOOK_URL -Method Post -Body $payload -ContentType "application/json"
            Write-Host "‚úÖ Discord notification sent successfully"
          } catch {
            Write-Host "‚ö†Ô∏è Failed to send Discord notification: $_"
            exit 0
          }

      - name: Notify build failure to Discord
        if: failure()
        env:
          DISCORD_WEBHOOK_URL: ${{ secrets.DISCORD_WEBHOOK_URL }}
        shell: pwsh
        run: |
          if (-not $env:DISCORD_WEBHOOK_URL) {
            exit 0
          }
          
          $version = "${{ steps.version.outputs.VERSION }}"
          $workflowUrl = "https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}"
          
          $payload = @{
            embeds = @(@{
              title = "‚ùå Build √©chou√©"
              description = "Le build de Discord Publisher v$version a √©chou√©"
              color = 15158332
              fields = @(
                @{
                  name = "Version"
                  value = "``$version``"
                  inline = $true
                },
                @{
                  name = "Build"
                  value = "√âchec ‚ùå"
                  inline = $true
                }
              )
              url = $workflowUrl
              timestamp = (Get-Date).ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffZ")
              footer = @{
                text = "GitHub Actions"
              }
            })
          } | ConvertTo-Json -Depth 10
          
          try {
            Invoke-RestMethod -Uri $env:DISCORD_WEBHOOK_URL -Method Post -Body $payload -ContentType "application/json"
          } catch {
            exit 0
          }