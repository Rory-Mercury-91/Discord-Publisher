name: Release Build

on:
  push:
    tags:
      - 'v*.*.*'

env:
  TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_PRIVATE_KEY_FRESH }}
  TAURI_SIGNING_PRIVATE_KEY_PASSWORD: ${{ secrets.TAURI_PASSWORD_FRESH }}

jobs:
  build-release:
    name: Build and Release
    runs-on: windows-latest
    permissions:
      contents: write
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          toolchain: stable

      - name: Rust cache
        uses: swatinem/rust-cache@v2
        with:
          workspaces: './src-tauri -> target'

      - name: Install dependencies
        run: |
          npm ci
          cd frontend && npm ci

      - name: Create .env files (root + frontend)
        shell: pwsh
        run: |
          $envContent = @"
          VITE_SUPABASE_URL=${{ secrets.VITE_SUPABASE_URL }}
          VITE_SUPABASE_ANON_KEY=${{ secrets.VITE_SUPABASE_ANON_KEY }}
          VITE_PUBLISHER_API_URL=${{ secrets.VITE_PUBLISHER_API_URL }}
          VITE_MASTER_ADMIN_CODE=${{ secrets.VITE_MASTER_ADMIN_CODE }}
          VITE_TAGS_MASTER_CODE=${{ secrets.VITE_TAGS_MASTER_CODE }}
          "@

          $envContent | Out-File -FilePath ".env" -Encoding utf8
          $envContent | Out-File -FilePath "frontend/.env" -Encoding utf8
          Write-Host "‚úÖ .env created"

      - name: Extract version from tag
        id: version
        shell: pwsh
        run: |
          $tag = "${{ github.ref_name }}"
          $version = $tag -replace '^v', ''
          echo "VERSION=$version" >> $env:GITHUB_OUTPUT
          Write-Host "‚úÖ Version: $version"

      - name: Set version from tag
        shell: pwsh
        run: |
          $version = "${{ steps.version.outputs.VERSION }}"
          Write-Host "üîß Setting version to $version..."
          
          # package.json
          $pkg = Get-Content package.json | ConvertFrom-Json
          $pkg.version = $version
          $pkg | ConvertTo-Json -Depth 100 | Set-Content package.json -Encoding utf8
          
          # tauri.conf.json
          $tauri = Get-Content src-tauri/tauri.conf.json | ConvertFrom-Json
          $tauri.version = $version
          $tauri | ConvertTo-Json -Depth 100 | Set-Content src-tauri/tauri.conf.json -Encoding utf8
          
          # Cargo.toml - SEULEMENT la version dans [package]
          $cargoContent = Get-Content src-tauri/Cargo.toml -Raw
          if ($cargoContent -match '\[package\]([\s\S]*?)(?=\n\[|$)') {
            $packageSection = $matches[1]
            $updatedSection = $packageSection -replace '(?m)^version\s*=\s*"[^"]+"', "version = `"$version`""
            $cargoContent = $cargoContent -replace [regex]::Escape($packageSection), $updatedSection
            $cargoContent | Set-Content src-tauri/Cargo.toml -NoNewline -Encoding utf8
            Write-Host "‚úÖ All versions updated"
          } else {
            Write-Host "‚ùå Could not find [package] section"
            exit 1
          }

      - name: Clean Cargo cache
        shell: pwsh
        run: |
          Write-Host "üßπ Cleaning Cargo cache..."
          if (Test-Path "src-tauri/Cargo.lock") {
            Remove-Item "src-tauri/Cargo.lock" -Force
          }
          cd src-tauri
          cargo clean

      - name: Verify signing keys
        shell: pwsh
        run: |
          if (-not $env:TAURI_SIGNING_PRIVATE_KEY) {
            Write-Host "‚ùå TAURI_SIGNING_PRIVATE_KEY not set"
            exit 1
          }
          if (-not $env:TAURI_SIGNING_PRIVATE_KEY_PASSWORD) {
            Write-Host "‚ùå TAURI_SIGNING_PRIVATE_KEY_PASSWORD not set"
            exit 1
          }
          Write-Host "‚úÖ Signing keys verified"

      - name: Build application
        env:
          TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_PRIVATE_KEY_FRESH }}
          TAURI_SIGNING_PRIVATE_KEY_PASSWORD: ${{ secrets.TAURI_PASSWORD_FRESH }}
        run: npm run build

      - name: List build artifacts
        shell: pwsh
        run: |
          Write-Host "üì¶ Listing artifacts..."
          if (Test-Path "src-tauri/target/release/bundle/nsis") {
            Get-ChildItem -Recurse src-tauri/target/release/bundle/nsis
          }

      - name: Create portable version
        shell: pwsh
        run: |
          $version = "${{ steps.version.outputs.VERSION }}"
          $exePath = "src-tauri/target/release/app.exe"
          $portableName = "Discord_Publisher_${version}_portable.exe"
          
          if (Test-Path $exePath) {
            Copy-Item $exePath $portableName
            $fileSize = (Get-Item $portableName).Length / 1MB
            Write-Host "‚úÖ Portable: $($fileSize.ToString('F2')) MB"
          } else {
            Write-Host "‚ùå exe not found"
            exit 1
          }

      - name: Generate latest.json CORRECTLY
        shell: pwsh
        run: |
          $version = "${{ steps.version.outputs.VERSION }}"
          $repoUrl = "https://github.com/${{ github.repository }}"
          $pubDate = (Get-Date).ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffZ")
          
          Write-Host "üîß Generating latest.json..."
          
          # Trouver le setup NSIS et sa signature
          $setupFiles = Get-ChildItem -Path "src-tauri/target/release/bundle/nsis" -Filter "*-setup.exe"
          
          if ($setupFiles.Count -eq 0) {
            Write-Host "‚ùå No setup file found"
            exit 1
          }
          
          $setupFile = $setupFiles[0]
          $setupFileName = $setupFile.Name
          $sigFileName = "$setupFileName.sig"
          $sigFile = Join-Path $setupFile.DirectoryName $sigFileName
          
          if (-not (Test-Path $sigFile)) {
            Write-Host "‚ùå Signature not found: $sigFile"
            Write-Host "Available files:"
            Get-ChildItem $setupFile.DirectoryName
            exit 1
          }

          # Lire la signature (SANS les sauts de ligne Windows)
          $signatureContent = (Get-Content -Path $sigFile -Raw).Trim()
          
          Write-Host "‚úÖ Setup file: $setupFileName"
          Write-Host "‚úÖ Signature length: $($signatureContent.Length) chars"
          Write-Host "üìã Signature preview: $($signatureContent.Substring(0, [Math]::Min(50, $signatureContent.Length)))..."
          
          # Cr√©er le JSON conforme au format Tauri
          $latestJson = @{
            version = $version
            notes = "Nouvelle version de Discord Publisher"
            pub_date = $pubDate
            platforms = @{
              "windows-x86_64" = @{
                signature = $signatureContent
                url = "$repoUrl/releases/download/${{ github.ref_name }}/$setupFileName"
              }
            }
          } | ConvertTo-Json -Depth 10 -Compress
          
          # Sauvegarder SANS BOM
          [System.IO.File]::WriteAllText("latest.json", $latestJson, [System.Text.UTF8Encoding]::new($false))
          
          Write-Host "‚úÖ latest.json created"
          Write-Host "üìÑ Content:"
          Get-Content "latest.json"

      - name: Verify latest.json format
        shell: pwsh
        run: |
          Write-Host "üîç Verifying latest.json..."
          $json = Get-Content "latest.json" -Raw | ConvertFrom-Json
          
          if (-not $json.version) {
            Write-Host "‚ùå Missing version"
            exit 1
          }
          if (-not $json.platforms.'windows-x86_64'.signature) {
            Write-Host "‚ùå Missing signature"
            exit 1
          }
          if (-not $json.platforms.'windows-x86_64'.url) {
            Write-Host "‚ùå Missing URL"
            exit 1
          }
          
          Write-Host "‚úÖ latest.json format is valid"
          Write-Host "   Version: $($json.version)"
          Write-Host "   Signature: $($json.platforms.'windows-x86_64'.signature.Substring(0, 50))..."
          Write-Host "   URL: $($json.platforms.'windows-x86_64'.url)"

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v1
        with:
          files: |
            src-tauri/target/release/bundle/nsis/*-setup.exe
            src-tauri/target/release/bundle/nsis/*-setup.exe.sig
            latest.json
            Discord_Publisher_${{ steps.version.outputs.VERSION }}_portable.exe
          name: Discord Publisher v${{ steps.version.outputs.VERSION }}
          body: |
            ## üéâ Nouvelle version : ${{ steps.version.outputs.VERSION }}
            
            ### üì¶ Fichiers disponibles
            
            - **Installateur NSIS** : Installation avec mise √† jour automatique
            - **Version portable** : Ex√©cutable standalone
            
            ### üîß Installation
            
            #### Installateur (recommand√©)
            1. T√©l√©charger `Discord Publisher_*_x64-setup.exe`
            2. Ex√©cuter et suivre les instructions
            3. Lancer depuis le menu D√©marrer
            
            #### Version portable
            1. T√©l√©charger `Discord_Publisher_${{ steps.version.outputs.VERSION }}_portable.exe`
            2. Double-cliquer pour lancer (aucune installation requise)
            
            ### üîÑ Mise √† jour automatique
            
            L'application d√©tecte automatiquement les nouvelles versions.
            
            **Options d'installation disponibles :**
            - ‚úÖ **Mode standard** (recommand√©) : Installation sans droits admin
            - üîê **Mode admin** : Avec √©l√©vation UAC (si n√©cessaire)
            
            ---
            
            **Build** : ${{ github.event.head_commit.timestamp }}  
            **Commit** : `${{ github.sha }}`
          draft: false
          prerelease: false
          generate_release_notes: true
          fail_on_unmatched_files: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Send Discord Notification
        if: success()
        env:
          DISCORD_WEBHOOK_URL: ${{ secrets.DISCORD_WEBHOOK_URL }}
        shell: pwsh
        run: |
          if (-not $env:DISCORD_WEBHOOK_URL) {
            Write-Host "Discord webhook not configured"
            exit 0
          }
          
          $version = "${{ steps.version.outputs.VERSION }}"
          $releaseUrl = "https://github.com/${{ github.repository }}/releases/tag/${{ github.ref_name }}"
          
          $payload = @{
            embeds = @(@{
              title = "üöÄ Nouvelle version disponible !"
              description = "Discord Publisher v$version"
              color = 5814783
              url = $releaseUrl
              timestamp = (Get-Date).ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffZ")
            })
          } | ConvertTo-Json -Depth 10
          
          try {
            Invoke-RestMethod -Uri $env:DISCORD_WEBHOOK_URL -Method Post -Body $payload -ContentType "application/json"
            Write-Host "‚úÖ Discord notification sent"
          } catch {
            Write-Host "‚ö†Ô∏è Discord notification failed: $_"
          }
